document.addEventListener("DOMContentLoaded", () => { let e = document.querySelector(".logo-slider-container"), t = document.querySelector(".logo-slider-track"), o = Array.from(t.querySelectorAll("img.provider-logo")); if (!e || !t || 0 === o.length) { console.warn("Logo slider container, track, or logos not found."); return } let r; function l() { let r = t.scrollLeft + t.clientWidth / 2, l = null, n = 1 / 0; if (o.forEach(e => { if (null !== e.offsetParent && e.offsetWidth > 0 && e.offsetHeight > 0) { let t = e.offsetLeft + e.offsetWidth / 2, o = Math.abs(t - r); o < n && (n = o, l = e) } }), o.forEach(e => { e.classList.remove("is-centered-logo") }), l) { l.classList.add("is-centered-logo"); let i = l.offsetWidth, s = l.offsetHeight; e.style.setProperty("--frame-width", i + 16 + "px"), e.style.setProperty("--frame-height", s + 16 + "px") } else e.offsetHeight > 0 && (e.style.setProperty("--frame-width", "150px"), e.style.setProperty("--frame-height", "100px")) } function n() { let e = o.map(e => new Promise(t => { e.complete ? t() : (e.onload = t, e.onerror = t) })); Promise.all(e).then(() => { }) } window.updateSliderFrameForFirstLogo = () => { document.body.classList.contains("logos-open") && o.length > 0 && null !== t.offsetParent && (o[0].scrollIntoView({ behavior: "auto", block: "nearest", inline: "center" }), setTimeout(l, 20)) }, "complete" === document.readyState ? n() : window.addEventListener("load", n), "onscrollend" in t ? t.addEventListener("scrollend", l) : t.addEventListener("scroll", () => { clearTimeout(r), r = setTimeout(l, 66) }, { passive: !0 }); let i = document.getElementById("trigger-snap-to-experience"), s = document.getElementById("experience"), a = window.scrollY, c = !1, d = !0; if (!i || !s) { console.warn("Snap scrolling to Experience: Trigger or section not found."); return } let f = new IntersectionObserver(e => { e.forEach(e => { let t = window.scrollY, o = t > a; if (o && e.isIntersecting && d && !c) { let r = s.getBoundingClientRect(); r.top > .1 * window.innerHeight && (c = !0, d = !1, s.scrollIntoView({ behavior: "smooth" }), setTimeout(() => { c = !1, setTimeout(() => d = !0, 500) }, 1200)) } else o || e.isIntersecting || !(e.boundingClientRect.top > 0) || (d = !0); a = t }) }, { threshold: .1 }); f.observe(i) });